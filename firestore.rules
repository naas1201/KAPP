
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for reusable logic
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }
    
    // Check the /users collection for the user's role
    function getUserRole(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data.role;
    }

    function isDoctor() {
      return isSignedIn() && getUserRole(request.auth.uid) == 'doctor';
    }

    function isAdmin() {
       return isSignedIn() && getUserRole(request.auth.uid) == 'admin';
    }

    /**
     * @description Stores user roles. Admin can write, user can create their own doc on signup.
     */
    match /users/{userId} {
      allow read, write: if isAdmin();
      // Allow a user to create their own user document if one doesn't exist.
      // This is used for when a user signs up via Google and doesn't have a pre-made role.
      // The email is used as the document ID for simplicity in this prototype.
      allow create: if isSignedIn() && request.resource.data.email == request.auth.token.email;
    }


    /**
     * Checks if the requesting user is an authorized doctor for a given patient.
     * Authorization is determined by the existence of a document in the doctor's
     * own patient list. This is a performant denormalized ACL check.
     * In a real-world scenario, an admin or cloud function would create this record.
     */
    function isAuthorizedDoctorForPatient(patientId) {
      return isDoctor() && exists(/databases/$(database)/documents/doctors/$(request.auth.uid)/authorizedPatients/$(patientId));
    }
    
    /**
     * Grants access if the user is the patient themselves or an authorized doctor for them.
     */
    function canAccessPatientData(patientId) {
      return isOwner(patientId) || isAuthorizedDoctorForPatient(patientId) || isAdmin();
    }

    /**
     * @description Manages patient profiles. Only the patient can create. Patient or authorized doctor can read/update it.
     */
    match /patients/{patientId} {
      allow get, update: if canAccessPatientData(patientId);
      allow list: if isAdmin();
      allow create: if isOwner(patientId); // Patient creates their own record
      allow delete: if isAdmin();

      /**
       * @description Secures patient appointments, treatment records, and prescriptions.
       * Access is inherited from the parent patient document.
       */
      match /appointments/{appointmentId} {
        allow read, create: if canAccessPatientData(patientId);
        allow update, delete: if isAuthorizedDoctorForPatient(patientId) || isAdmin(); // Only docs/admins can change appointments
      }
      
      match /treatmentRecords/{recordId} {
        allow read: if canAccessPatientData(patientId);
        allow write: if isAuthorizedDoctorForPatient(patientId) || isAdmin(); // Only docs/admins can write treatment records
      }
      
       match /prescriptions/{prescriptionId} {
        allow read: if canAccessPatientData(patientId);
        allow write: if isAuthorizedDoctorForPatient(patientId) || isAdmin(); // Only docs/admins can write prescriptions
      }
    }

    /**
     * @description Publicly readable collection of all appointments, used by doctors.
     * This denormalizes appointment data for easier querying by doctors.
     * SECURITY: Only doctors can read this collection. Patients cannot list all appointments.
     * Writes are handled via the patient's subcollection for security, then mirrored here by a function.
     */
     match /appointments/{appointmentId} {
        allow read: if isDoctor() || isAdmin();
        // Disallow direct writes. Writes must go through /patients/{patientId}/appointments/{appointmentId}
        allow write: if false; 
     }

     /**
      * @description Denormalized collection of all prescriptions for easier querying by staff.
      * Writable only via a function that mirrors from the patient's subcollection.
      */
     match /prescriptions/{prescriptionId} {
        allow read, list: if isAdmin();
        allow write: if false; // Writes must be mirrored from patient's subcollection
     }

    /**
     * @description Manages doctor profiles. Profiles are readable by any authenticated user for booking.
     */
    match /doctors/{doctorId} {
      allow get, list: if isSignedIn();
      allow create: if isOwner(doctorId); // A doctor can create their own profile
      allow update: if isOwner(doctorId) || isAdmin();
      allow delete: if isAdmin();
      
      /**
       * @description This path is an Access Control List (ACL). It links doctors to patients they can access.
       * Only admins can grant/revoke doctor access to a patient.
       */
      match /authorizedPatients/{patientId} {
        allow write: if isAdmin();
        // Read access is checked via exists() in other rules, no direct read needed.
        allow read: if isAuthorizedDoctorForPatient(patientId);
      }

      /**
       * @description A doctor's individual list of services and prices.
       * Only the doctor themselves or an admin can write to this.
       * Any authenticated user can read this to see what a doctor offers.
       */
      match /services/{serviceId} {
        allow read: if isSignedIn();
        allow write: if isOwner(doctorId) || isAdmin();
      }
    }

    /**
     * @description Master list of all treatments. Readable by any authenticated user.
     * Writable only by admins.
     */
    match /treatments/{treatmentId} {
      allow get, list: if isSignedIn();
      allow write: if isAdmin();
    }


    /**
     * @description Stores leads from contact forms. Writable by any source (even unauthenticated), but manageable only by staff.
     */
    match /leads/{leadId} {
      allow read, list: if isAdmin();
      allow create: if true;
      allow update, delete: if isAdmin();
    }

    /**
     * @description Stores public Frequently Asked Questions. Readable by anyone. Writable by admin.
     */
    match /faqs/{faqId} {
      allow get, list: if true;
      allow write: if isAdmin();
    }

    /**
     * @description Temporary signaling collection for WebRTC video calls.
     * Only the doctor who created it or the involved patient can read/write.
     */
    match /video-calls/{roomId} {
      // The patientId should be stored in the document to verify access.
      allow read, write: if isSignedIn() && (isAuthorizedDoctorForPatient(resource.data.patientId) || isOwner(resource.data.patientId));
    }
     /**
     * @description Chat rooms between doctors and patients.
     */
    match /chatRooms/{roomId} {
      // Participants can get, list, and update room details (e.g., unread count)
      allow read, update: if isSignedIn() && request.auth.uid in resource.data.participants;
      // Only doctors can create new rooms
      allow create: if isDoctor();

      /**
       * @description Messages within a chat room.
       */
      match /messages/{messageId} {
        // Participants can read messages
        allow get, list: if isSignedIn() && request.auth.uid in get(/databases/$(database)/documents/chatRooms/$(roomId)).data.participants;
        // Participants can add new messages if the room is open
        allow create: if isSignedIn() && request.auth.uid in get(/databases/$(database)/documents/chatRooms/$(roomId)).data.participants
                     && get(/databases/$(database)/documents/chatRooms/$(roomId)).data.status == 'open';
        // Allow updating message (e.g. for reactions, read status) by participants
        allow update: if isSignedIn() && request.auth.uid in get(/databases/$(database)/documents/chatRooms/$(roomId)).data.participants;
      }
    }

    /**
     * @description Stores reports filed by doctors against patients.
     */
    match /reports/{reportId} {
      // Only doctors can create reports
      allow create: if isDoctor();
      // Only admins can read, update, or delete reports
      allow read, write: if isAdmin();
    }

    /**
     * @description Stores ratings for consultations.
     */
    match /ratings/{ratingId} {
      // Only signed-in users can create ratings
      allow create: if isSignedIn();
      // Only admins can read all ratings
      allow read, list: if isAdmin();
    }

    /**
     * @description Stores name change requests from patients.
     * Patients can create requests for their own accounts.
     * Only admins can read all requests and process them.
     */
    match /nameChangeRequests/{requestId} {
      // Patients can create their own name change requests
      allow create: if isSignedIn() && request.resource.data.patientId == request.auth.uid;
      // Patients can read their own requests
      allow read: if isSignedIn() && resource.data.patientId == request.auth.uid;
      // Only admins can list all requests and update/delete them
      allow list, update, delete: if isAdmin();
    }

    /**
     * @description Stores medical information filled by patients.
     * Only visible to doctors and the patient themselves.
     */
    match /medicalInfo/{patientId} {
      // Patient can read and write their own medical info
      allow read, write: if isSignedIn() && isOwner(patientId);
      // Authorized doctors can read medical info
      allow read: if isAuthorizedDoctorForPatient(patientId);
      // Admins can read but not modify medical info directly
      allow read: if isAdmin();
    }
  }
}
