
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ===== OWASP SECURITY HELPERS =====
    
    // Helper functions for reusable logic
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }
    
    // Check the /users collection for the user's role
    function getUserRole(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data.role;
    }

    function isDoctor() {
      return isSignedIn() && getUserRole(request.auth.uid) == 'doctor';
    }

    function isAdmin() {
       return isSignedIn() && getUserRole(request.auth.uid) == 'admin';
    }
    
    // OWASP: Input validation - Check string length to prevent DoS
    function isValidStringLength(str, maxLength) {
      return str is string && str.size() <= maxLength;
    }
    
    // OWASP: Validate email format (RFC 5322 compliant - no dots at start/end, no consecutive dots)
    function isValidEmailFormat(email) {
      return email is string 
        && email.matches('^[a-zA-Z0-9]([a-zA-Z0-9._%-]*[a-zA-Z0-9])?@[a-zA-Z0-9]([a-zA-Z0-9.-]*[a-zA-Z0-9])?\\.[a-zA-Z]{2,}$')
        && email.size() <= 254
        && !email.matches('.*\\.\\..+'); // No consecutive dots
    }
    
    // OWASP: Validate phone number (Philippine format)
    function isValidPhoneFormat(phone) {
      return phone is string 
        && phone.matches('^(\\+63|0)?9[0-9]{9}$');
    }
    
    // OWASP: Prevent script injection in text fields
    function noScriptTags(str) {
      return str is string 
        && !str.lower().matches('.*<script.*')
        && !str.lower().matches('.*javascript:.*')
        && !str.lower().matches('.*on[a-z]+\\s*=.*');
    }
    
    // OWASP: Validate document size to prevent DoS
    function isValidDocumentSize() {
      return request.resource.data.keys().size() <= 100;
    }
    
    // OWASP: Rate limiting awareness - timestamps must be recent
    function isRecentTimestamp(ts) {
      return ts is timestamp 
        && ts >= request.time - duration.value(1, 'h')
        && ts <= request.time + duration.value(5, 'm');
    }

    /**
     * @description Stores user roles. Admin can write, user can create their own doc on signup.
     * SECURITY: Email-based document IDs for role lookup
     */
    match /users/{userId} {
      allow read, write: if isAdmin();
      // Allow a user to create their own user document if one doesn't exist.
      // OWASP: Validate the email matches the authenticated user's email
      allow create: if isSignedIn() 
        && request.resource.data.email == request.auth.token.email
        && isValidEmailFormat(request.resource.data.email)
        && request.resource.data.role in ['patient']; // Can only self-assign patient role
    }


    /**
     * Checks if the requesting user is an authorized doctor for a given patient.
     * Authorization is determined by the existence of a document in the doctor's
     * own patient list. This is a performant denormalized ACL check.
     */
    function isAuthorizedDoctorForPatient(patientId) {
      return isDoctor() && exists(/databases/$(database)/documents/doctors/$(request.auth.uid)/authorizedPatients/$(patientId));
    }
    
    /**
     * Grants access if the user is the patient themselves or an authorized doctor for them.
     */
    function canAccessPatientData(patientId) {
      return isOwner(patientId) || isAuthorizedDoctorForPatient(patientId) || isAdmin();
    }

    /**
     * @description Manages patient profiles. 
     * SECURITY: Validates input data, prevents XSS
     */
    match /patients/{patientId} {
      allow get, update: if canAccessPatientData(patientId)
        && isValidDocumentSize();
      allow list: if isAdmin();
      allow create: if isOwner(patientId)
        && isValidDocumentSize()
        && isValidStringLength(request.resource.data.firstName, 100)
        && isValidStringLength(request.resource.data.lastName, 100)
        && noScriptTags(request.resource.data.firstName)
        && noScriptTags(request.resource.data.lastName);
      allow delete: if isAdmin();

      /**
       * @description Secures patient appointments, treatment records, and prescriptions.
       * SECURITY: Validates booking data
       */
      match /appointments/{appointmentId} {
        allow read, create: if canAccessPatientData(patientId)
          && isValidDocumentSize()
          && isValidStringLength(request.resource.data.serviceType, 200)
          && noScriptTags(request.resource.data.patientNotes);
        allow update, delete: if isAuthorizedDoctorForPatient(patientId) || isAdmin();
      }
      
      /**
       * @description Medical records - doctor eyes only
       * SECURITY: Strict access control, input validation
       */
      match /medicalRecords/{recordId} {
        allow read: if canAccessPatientData(patientId);
        allow write: if (isAuthorizedDoctorForPatient(patientId) || isAdmin())
          && isValidDocumentSize()
          && noScriptTags(request.resource.data.diagnosis)
          && noScriptTags(request.resource.data.treatmentPlan);
      }
      
      match /treatmentRecords/{recordId} {
        allow read: if canAccessPatientData(patientId);
        allow write: if (isAuthorizedDoctorForPatient(patientId) || isAdmin())
          && isValidDocumentSize();
      }
      
       match /prescriptions/{prescriptionId} {
        allow read: if canAccessPatientData(patientId);
        allow write: if (isAuthorizedDoctorForPatient(patientId) || isAdmin())
          && isValidDocumentSize()
          && isValidStringLength(request.resource.data.prescriptionNumber, 50);
      }
    }

    /**
     * @description Publicly readable collection of all appointments, used by doctors.
     * SECURITY: Read-only for doctors, no direct writes
     */
     match /appointments/{appointmentId} {
        allow read: if isDoctor() || isAdmin();
        // Disallow direct writes - writes must go through patient subcollection
        allow write: if false; 
     }

     /**
      * @description Denormalized prescriptions collection
      * SECURITY: Admin read-only, no direct writes
      */
     match /prescriptions/{prescriptionId} {
        allow read, list: if isAdmin();
        allow write: if false;
     }

    /**
     * @description Manages doctor profiles.
     * SECURITY: Validates license numbers and credentials
     */
    match /doctors/{doctorId} {
      allow get, list: if isSignedIn();
      allow create: if isOwner(doctorId)
        && isValidDocumentSize()
        && isValidStringLength(request.resource.data.licenseNumber, 50);
      allow update: if (isOwner(doctorId) || isAdmin())
        && isValidDocumentSize();
      allow delete: if isAdmin();
      
      /**
       * @description ACL for doctor-patient relationships
       * SECURITY: Admin-only management
       */
      match /authorizedPatients/{patientId} {
        allow write: if isAdmin();
        allow read: if isAuthorizedDoctorForPatient(patientId);
      }

      /**
       * @description Doctor's services and pricing
       */
      match /services/{serviceId} {
        allow read: if isSignedIn();
        allow write: if (isOwner(doctorId) || isAdmin())
          && isValidDocumentSize();
      }
      
      /**
       * @description Doctor's digital signature and stamp
       * SECURITY: Only the doctor can update their own signature/stamp
       */
      match /credentials/{credentialId} {
        allow read: if isOwner(doctorId) || isAdmin();
        allow write: if isOwner(doctorId)
          && isValidDocumentSize();
      }
    }

    /**
     * @description Master treatments list
     */
    match /treatments/{treatmentId} {
      allow get, list: if isSignedIn();
      allow write: if isAdmin();
    }

    /**
     * @description Discount codes
     * SECURITY: Read for validation, write for admin only
     */
    match /discountCodes/{codeId} {
      allow read: if isSignedIn();
      allow write: if isAdmin();
    }

    /**
     * @description Contact form leads
     * SECURITY: Rate limiting awareness - check timestamp
     */
    match /leads/{leadId} {
      allow read, list: if isAdmin();
      allow create: if true
        && isValidDocumentSize()
        && isValidStringLength(request.resource.data.name, 200)
        && isValidStringLength(request.resource.data.message, 5000)
        && noScriptTags(request.resource.data.name)
        && noScriptTags(request.resource.data.message);
      allow update, delete: if isAdmin();
    }

    /**
     * @description Public FAQs
     */
    match /faqs/{faqId} {
      allow get, list: if true;
      allow write: if isAdmin();
    }

    /**
     * @description WebRTC signaling for video calls
     * SECURITY: Scoped to authorized participants only
     */
    match /video-calls/{roomId} {
      allow read, write: if isSignedIn() 
        && (isAuthorizedDoctorForPatient(resource.data.patientId) || isOwner(resource.data.patientId));
      allow create: if isDoctor()
        && isValidDocumentSize();
    }
    
    /**
     * @description Chat rooms between doctors and patients
     * SECURITY: Participant-only access, message content validation
     */
    match /chatRooms/{roomId} {
      allow read, update: if isSignedIn() && request.auth.uid in resource.data.participants;
      allow create: if isDoctor();

      match /messages/{messageId} {
        allow get, list: if isSignedIn() 
          && request.auth.uid in get(/databases/$(database)/documents/chatRooms/$(roomId)).data.participants;
        allow create: if isSignedIn() 
          && request.auth.uid in get(/databases/$(database)/documents/chatRooms/$(roomId)).data.participants
          && get(/databases/$(database)/documents/chatRooms/$(roomId)).data.status == 'open'
          && isValidStringLength(request.resource.data.content, 10000)
          && noScriptTags(request.resource.data.content);
        allow update: if isSignedIn() 
          && request.auth.uid in get(/databases/$(database)/documents/chatRooms/$(roomId)).data.participants;
      }
    }

    /**
     * @description Reports filed by doctors
     */
    match /reports/{reportId} {
      allow create: if isDoctor()
        && isValidDocumentSize()
        && isValidStringLength(request.resource.data.reason, 5000);
      allow read, write: if isAdmin();
    }

    /**
     * @description Consultation ratings
     * SECURITY: One rating per consultation
     */
    match /ratings/{ratingId} {
      allow create: if isSignedIn()
        && isValidDocumentSize()
        && request.resource.data.rating >= 1
        && request.resource.data.rating <= 5;
      allow read, list: if isAdmin();
      allow read: if isDoctor() && resource.data.ratedId == request.auth.uid;
    }

    /**
     * @description Name change requests
     * SECURITY: Patient-initiated, admin-approved
     */
    match /nameChangeRequests/{requestId} {
      allow create: if isSignedIn() 
        && request.resource.data.patientId == request.auth.uid
        && isValidStringLength(request.resource.data.newLastName, 100)
        && noScriptTags(request.resource.data.newLastName);
      allow read: if isSignedIn() && resource.data.patientId == request.auth.uid;
      allow list, update, delete: if isAdmin();
    }

    /**
     * @description Patient medical information
     */
    match /medicalInfo/{patientId} {
      allow read, write: if isSignedIn() && isOwner(patientId)
        && isValidDocumentSize();
      allow read: if isAuthorizedDoctorForPatient(patientId);
      allow read: if isAdmin();
    }

    /**
     * @description Notifications for doctors
     */
    match /notifications/{notificationId} {
      allow create: if isAdmin();
      allow read: if isDoctor() && resource.data.doctorId == request.auth.uid;
      allow update: if isDoctor() && resource.data.doctorId == request.auth.uid;
      allow read, delete: if isAdmin();
    }
    
    /**
     * @description Doctor gamification data
     * SECURITY: Read-only for doctors, system-managed writes
     */
    match /doctorGamification/{doctorId} {
      allow read: if isOwner(doctorId) || isAdmin();
      allow write: if isAdmin(); // Only system/admin can update gamification
    }
  }
}
