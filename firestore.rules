
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for reusable logic
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }
    
    function isDoctor() {
        return exists(/databases/$(database)/documents/doctors/$(request.auth.uid));
    }

    /**
     * Checks if the requesting user is an authorized doctor for a given patient.
     * Authorization is determined by the existence of a document in the doctor's
     * own patient list. This is a performant denormalized ACL check.
     * In a real-world scenario, an admin or cloud function would create this record.
     */
    function isAuthorizedDoctorForPatient(patientId) {
      return isDoctor() && exists(/databases/$(database)/documents/doctors/$(request.auth.uid)/authorizedPatients/$(patientId));
    }
    
    /**
     * Grants access if the user is the patient themselves or an authorized doctor for them.
     */
    function canAccessPatientData(patientId) {
      return isOwner(patientId) || isAuthorizedDoctorForPatient(patientId);
    }
    
    // Admins have special privileges. This could be based on a custom claim.
    function isAdmin() {
      // For this example, we'll allow any doctor to be an admin.
      // In production, you'd use custom claims: request.auth.token.admin == true;
      return isDoctor();
    }

    /**
     * @description Manages patient profiles. Only the patient can create. Patient or authorized doctor can read/update it.
     */
    match /patients/{patientId} {
      allow get, update: if canAccessPatientData(patientId) || isAdmin();
      allow list: if isAdmin();
      allow create: if isOwner(patientId); // Patient creates their own record
      allow delete: if isAdmin();

      /**
       * @description Secures patient appointments, treatment records, and prescriptions.
       * Access is inherited from the parent patient document.
       */
      match /appointments/{appointmentId} {
        allow read, create: if canAccessPatientData(patientId);
        allow update, delete: if isAuthorizedDoctorForPatient(patientId) || isAdmin(); // Only docs/admins can change appointments
      }
      
      match /treatmentRecords/{recordId} {
        allow read: if canAccessPatientData(patientId);
        allow write: if isAuthorizedDoctorForPatient(patientId) || isAdmin(); // Only docs/admins can write treatment records
      }
      
       match /prescriptions/{prescriptionId} {
        allow read: if canAccessPatientData(patientId);
        allow write: if isAuthorizedDoctorForPatient(patientId) || isAdmin(); // Only docs/admins can write prescriptions
      }
    }

    /**
     * @description Publicly readable collection of all appointments, used by doctors.
     * This denormalizes appointment data for easier querying by doctors.
     * SECURITY: Only doctors can read this collection. Patients cannot list all appointments.
     * Writes are handled via the patient's subcollection for security, then mirrored here by a function.
     */
     match /appointments/{appointmentId} {
        allow read: if isDoctor() || isAdmin();
        // Disallow direct writes. Writes must go through /patients/{patientId}/appointments/{appointmentId}
        allow write: if false; 
     }

     /**
      * @description Denormalized collection of all prescriptions for easier querying by staff.
      * Writable only via a function that mirrors from the patient's subcollection.
      */
     match /prescriptions/{prescriptionId} {
        allow read, list: if isAdmin();
        allow write: if false; // Writes must be mirrored from patient's subcollection
     }

    /**
     * @description Manages doctor profiles. Profiles are readable by any authenticated user for booking.
     */
    match /doctors/{doctorId} {
      allow get, list: if isSignedIn();
      allow create: if isOwner(doctorId); // A doctor can create their own profile
      allow update: if isOwner(doctorId) || isAdmin();
      allow delete: if isAdmin();
      
      /**
       * @description This path is an Access Control List (ACL). It links doctors to patients they can access.
       * Only admins can grant/revoke doctor access to a patient.
       */
      match /authorizedPatients/{patientId} {
        allow write: if isAdmin();
        // Read access is checked via exists() in other rules, no direct read needed.
        allow read: if isAuthorizedDoctorForPatient(patientId);
      }

      /**
       * @description A doctor's individual list of services and prices.
       * Only the doctor themselves or an admin can write to this.
       * Any authenticated user can read this to see what a doctor offers.
       */
      match /services/{serviceId} {
        allow read: if isSignedIn();
        allow write: if isOwner(doctorId) || isAdmin();
      }
    }

    /**
     * @description Master list of all treatments. Readable by any authenticated user.
     * Writable only by admins.
     */
    match /treatments/{treatmentId} {
      allow get, list: if isSignedIn();
      allow write: if isAdmin();
    }


    /**
     * @description Stores leads from contact forms. Writable by any source (even unauthenticated), but manageable only by staff.
     */
    match /leads/{leadId} {
      allow read, list: if isAdmin();
      allow create: if true;
      allow update, delete: if isAdmin();
    }

    /**
     * @description Stores public Frequently Asked Questions. Readable by anyone. Writable by admin.
     */
    match /faqs/{faqId} {
      allow get, list: if true;
      allow write: if isAdmin();
    }

    /**
     * @description Temporary signaling collection for WebRTC video calls.
     * Only the doctor who created it or the involved patient can read/write.
     */
    match /video-calls/{roomId} {
      // The patientId should be stored in the document to verify access.
      allow read, write: if isSignedIn() && (isAuthorizedDoctorForPatient(resource.data.patientId) || isOwner(resource.data.patientId));
    }
  }
}
